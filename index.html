<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>InsulinRotate (standalone)</title>

    <!-- Tailwind via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Component styles using Tailwind Play CDN (@apply inside @layer) -->
    <style type="text/tailwindcss">
      @layer components {
        .btn-base { @apply inline-flex items-center justify-center rounded-md font-medium transition-colors
                           focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none; }
        .btn { @apply btn-base bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-600 px-4 h-10; }
        .btn-outline { @apply btn-base border border-gray-300 bg-white text-gray-800 hover:bg-gray-50 focus:ring-gray-400 px-4 h-10; }
        .badge { @apply inline-flex items-center px-2 py-0.5 rounded-md text-xs font-medium bg-gray-100 text-gray-900 border border-gray-200; }
        .card { @apply border rounded-lg bg-white/70; }
        .card-head { @apply border-b text-center text-sm text-gray-700 py-1; }
        .metric { @apply bg-white/60 rounded-lg p-3; }
      }
    </style>

    <!-- React 18 via CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel para permitir JSX no navegador -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      html, body, #root { height: 100%; }
      body { background: #f5f7fb; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-presets="react">
      const { useState, useEffect, useMemo } = React;

      // ====== Config/Chaves ======
      const SCHEMA_VERSION = 2;
      const LS_KEYS = {
        history: 'insulin-history',
        prefs: 'insulin-prefs',
        schema: 'insulin-schema-version',
      };
      const dayMs = 24*60*60*1000;

      // ====== Dados dos pontos ======
      const injectionPoints = {
        abdomen: {
          name: 'Abdômen',
          region: 'abdomen',
          points: [
            { id: 'abd_r1', name: 'Direito 1', side: 'right', position: { x: 45, y: 35 } },
            { id: 'abd_r2', name: 'Direito 2', side: 'right', position: { x: 45, y: 45 } },
            { id: 'abd_r3', name: 'Direito 3', side: 'right', position: { x: 45, y: 55 } },
            { id: 'abd_l1', name: 'Esquerdo 1', side: 'left',  position: { x: 55, y: 35 } },
            { id: 'abd_l2', name: 'Esquerdo 2', side: 'left',  position: { x: 55, y: 45 } },
            { id: 'abd_l3', name: 'Esquerdo 3', side: 'left',  position: { x: 55, y: 55 } },
          ],
        },
        thigh: {
          name: 'Coxa',
          region: 'thigh',
          points: [
            { id: 'th_r1', name: 'Direito 1', side: 'right', position: { x: 45, y: 75 } },
            { id: 'th_r2', name: 'Direito 2', side: 'right', position: { x: 45, y: 85 } },
            { id: 'th_l1', name: 'Esquerdo 1', side: 'left',  position: { x: 55, y: 75 } },
            { id: 'th_l2', name: 'Esquerdo 2', side: 'left',  position: { x: 55, y: 85 } },
          ],
        },
        arm: {
          name: 'Braço',
          region: 'arm',
          points: [
            { id: 'arm_r1', name: 'Direito 1', side: 'right', position: { x: 35, y: 40 } },
            { id: 'arm_l1', name: 'Esquerdo 1', side: 'left',  position: { x: 65, y: 40 } },
          ],
        },
      };

      const defaultPrefs = {
        cooldownDays: 7,
        alternateSide: true,
        alternateRegion: true,
        dailySlots: 2,
        enabledRegions: { abdomen: true, thigh: true, arm: true },
        language: 'pt',
      };

      // ====== Utils ======
      function loadJSON(key, fallback) {
        try { const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; }
        catch { return fallback; }
      }
      function saveJSON(key, value) { localStorage.setItem(key, JSON.stringify(value)); }
      function dist(p1, p2) { const dx = p1.x - p2.x; const dy = p1.y - p2.y; return Math.sqrt(dx*dx + dy*dy); }

      const pointById = (() => {
        const map = new Map();
        Object.values(injectionPoints).forEach(area => {
          area.points.forEach(pt => map.set(pt.id, { ...pt, region: area.region, areaName: area.name }));
        });
        return map;
      })();

      function getPointStatus(pointId, history, prefs) {
        const cdMs = (prefs?.cooldownDays ?? defaultPrefs.cooldownDays) * dayMs;
        const entries = history.filter(h => h.pointId === pointId).sort((a,b)=>b.ts-a.ts);
        if (!entries.length) return 'available';
        const elapsed = Date.now() - entries[0].ts;
        return elapsed >= cdMs ? 'available' : 'recent';
      }

      function suggestNextPoint(history, prefs) {
        const enabledRegions = prefs.enabledRegions || defaultPrefs.enabledRegions;
        const usable = Object.values(injectionPoints).filter(a => enabledRegions[a.region]).flatMap(a => a.points);
        if (!usable.length) return null;
        const last = history[0] ? pointById.get(history[0].pointId) : null;

        const pool = usable.map(pt => ({ pt, status: getPointStatus(pt.id, history, prefs) }));
        const avail = pool.filter(x => x.status === 'available');
        const base = avail.length ? avail : pool;

        const scored = base.map(({ pt, status }) => {
          let score = 0;
          if (status === 'available') score += 50;
          if (last) {
            if (prefs.alternateSide)   score += (pt.side   !== last.side   ? 20 : -10);
            if (prefs.alternateRegion) score += (pt.region !== last.region ? 15 :  -5);
            score += Math.min(20, dist(pt.position, last.position));
          }
          return { pt, score };
        }).sort((a,b)=>b.score-a.score);

        return scored[0]?.pt ?? null;
      }

      // ====== Silhueta vetorial ======
      const Silhouette = () => (
        <>
          <defs>
            <linearGradient id="silFill" x1="0" y1="0" x2="0" y2="1">
              <stop offset="0%" stop-color="#eef2f7"/>
              <stop offset="100%" stop-color="#dfe6ee"/>
            </linearGradient>
          </defs>
          <circle cx="50" cy="14.5" r="8.2" fill="url(#silFill)" stroke="#1f2937" stroke-width="0.7"/>
          <path d="M45 22.5 Q50 24 55 22.5 L55 26.5 Q50 27.5 45 26.5 Z"
                fill="url(#silFill)" stroke="#1f2937" stroke-width="0.7"/>
          <path d="M27,33 Q33,27 41,28 H59 Q67,27 73,33
                   C76.5,36.5 78,40.5 78,46
                   Q78,53 71.5,56.5
                   L71.5,76 Q71.5,85 74.5,91
                   C76,94.2 77,97.5 77,101.2
                   L77,106.5 Q73,108.5 68,108.8
                   L32,108.8 Q27,108.5 23,106.5
                   L23,101.2 C23,97.5 24,94.2 25.5,91
                   Q28.5,85 28.5,76
                   L28.5,56.5 Q22,53 22,46
                   C22,40.5 23.5,36.5 27,33 Z"
                fill="url(#silFill)" stroke="#1f2937" stroke-width="0.7"/>
        </>
      );

      // ====== App ======
      function App() {
        const [prefs, setPrefs] = useState(() => ({ ...defaultPrefs, ...loadJSON(LS_KEYS.prefs, {}) }));
        const [history, setHistory] = useState(() => loadJSON(LS_KEYS.history, []));
        const [manualSelection, setManualSelection] = useState(null);
        const suggestedPoint = useMemo(() => manualSelection || suggestNextPoint(history, prefs), [history, prefs, manualSelection]);

        const getStatusColor = (s) => s === 'available' ? 'fill-green-500/70' : 'fill-yellow-400/80';

        return (
          <div className="container mx-auto max-w-4xl p-4 space-y-4">
            <div className="card">
              <div className="card-head">Próximo ponto sugerido</div>
              <div className="p-4 grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="flex items-center justify-center">
                  <svg viewBox="0 0 100 120" className="w-full h-full" style={{ maxWidth:'380px' }}>
                    <Silhouette />
                    {Object.values(injectionPoints).flatMap(a=>a.points).map(pt=>{
                      const status=getPointStatus(pt.id, history, prefs);
                      const isSelected=(manualSelection?.id||suggestedPoint?.id)===pt.id;
                      return <circle key={pt.id} cx={pt.position.x} cy={pt.position.y} r={isSelected?3.2:2.5}
                              className={`${getStatusColor(status)} ${isSelected?'animate-pulse':''}`}
                              stroke={isSelected?'#fff':'#111'} strokeWidth={isSelected?1.2:0.6}
                              onClick={()=>setManualSelection(pt)} />;
                    })}
                  </svg>
                </div>
                <div>
                  {suggestedPoint &&
                    <div className="font-semibold">{pointById.get(suggestedPoint.id).areaName} · {suggestedPoint.name}</div>
                  }
                </div>
              </div>
            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
  </body>
</html>
